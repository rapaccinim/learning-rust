# Intro
## What is Rust
Rust is a programming language used for _system programming_, when resources are limited and programmers need to _save_ memory and CPUS.

## Why Rust
Rust is a good alternative to C/C++ for _system programming_ because:
* it's fast
* it's safe:
  * the Rust compiler prevents undefined behaviours
  * it has more restrictions, without loosing flexibility
  * allows to control memory and processor
* it enables parallel programming (_concurrency_)
* it can be used both for low-level systems programming and for making CLI apps, web servers and a lot more
* it's stable

## rustup
`rustup` is the installer for Rust.

It's the best way to install Rust.

[Here](https://rustup.rs/) you can find all the info for installation on your local machine.

### What comes with rustup
When installing `rustup`, you will also automatically install:
* `rustc`, the Rust compiler
* `cargo`, the Rust build system, package manager and general tool
* `rustdoc`, the Rust documentation tool
* `rustfmt`, an automatic formatter for Rust code

### Updating Rust
Really easy: `rustup update`

## Hello, world!
You can create your first `Hello, world!` in Rust in 2 ways:
* from scratch
* using `cargo`

### Hello, world! - from scratch
Create the file `hello_world.rs`, that will have the following code:
```
fn main() {
    println!("Hello, world!");
}
```
**[INFO]** In Rust, we indent with 4 spaces instead of a tab.

**[INFO]** `println!` with the `!` is not a function call, but a _macro_ call. TBD: link to macros.

Then you use the compiler to produce the binary executable:
```
rustc hello_world.rs
```
The compiler creates the `hello_world` file:
```
ls
hello_world  hello_world.rs
```
**[INFO]** Rust is an ahead-of-time compiled language: compilation is separated from execution.

Finally, you can run the executable:
```
./hello_world
Hello, world!
```
### Hello, world! - cargo
```
cargo new hello
     Created binary (application) `hello` package
```
I could have used the `--vcs none` option to override the default `git` configuration, avoiding to create `.git` and `.gitignore`.

`cargo` has created the `hello` package with:
```
ls hello/
Cargo.toml  src
```
* `Cargo.toml` holds metadata for the package (e.g. version, dependencies, etc.):
  * the format is [_TOML_](https://toml.io/en/) - _Tom's Obvious Minimal Language_
* `src` is a subdirectory with the Rust code
```
ls hello/src
main.rs
```
And inside `main.rs` there's already the code:
```
cat hello/src/main.rs
fn main() {
    println!("Hello, world!");
}
```
Then you can use `cargo run` in any point of the `hello` directory to compile and run the code:
```
cargo run
   Compiling hello v0.1.0 (/mnt/c/git/learning-rust/examples/1-hello-world/using-cargo/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 2.84s
     Running `target/debug/hello`
Hello, world!
```
Cargo creates a `Cargo.lock` file and the subdirectory `/target/debug` with the executable and other files/subdirectories:
```
ls target/debug/
build  deps  examples  hello  hello.d  incremental
```
You can also use:
* `cargo build` for building and producing the executable, without running the program. TBD specific page
* `cargo check` for compiling without producing the executable (it's faster!). TBD specific page
* `cargo clean` for removing artifacts generated by cargo. TBD specific page
